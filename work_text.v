/***********************************************************
* 
***********************************************************/
2018/01/18
发送无故停止；原因：发送错误使用DMA_PUSH...已解决
接收中断不稳定；原因：AGC导致...待解决
接收中断后查询first错误；原因不明...停止TX后不再查询first错误

2018/01/19
接收中断后查询first错误，接收数据结构体rx_dmadesc为：
struct rx_dmadesc
{
    struct rx_hd hd;
    struct phy_channel_info phy_info;
    uint32_t pattern;
    struct dma_desc dma_desc;
};

struct rx_hd
{
    uint32_t upatternrx;
    uint32_t next;
    ...
    uint32_t statinfo;
}

rx_hd就是Rx Header Descriptor，由MACHW所维护

/***********************************************************
01/19   :   
***********************************************************/
1、src填8对齐，dst填8对齐成功；
2、src填8对齐，dst填4对齐成功；
3、src填4对齐，dst填8对齐不成功；   传输长度错误
4、src填4对齐，dst填4对齐不成功；   传输长度错误

注释掉旋转代码和地址相减代码
/***********************************************************
* 01/23
***********************************************************/
1、已消除地址对发送接收的影响。
/***********************************************************
* 
***********************************************************/
修改了dma_ctrl.v,upstream_req_n_data.v,downstream_req.v,aligner.v
文件中关于DDR的地址算法部分。
/***********************************************************
* 01/24
***********************************************************/
1、修改了upstream_req_n_data.v中的请求数据格式，将数据字节长度放在
请求数据中发dma_if。
2、在dma_if中根据当前数据字节长度的低3bit决定tkeep的偏移。

/***********************************************************
* svn地址:file:///opt/svnroot/mustang_phy
***********************************************************/
AGC目前设为自动调整，可能会出现问题。

/***********************************************************
*  01/25
***********************************************************/
1、tx与rx存在冲突；
2、信号质量可能有影响；
3、一个板子配置成TX，一个板子配置成RX，接收不稳定。
4、CCA没有接导致收发状态不对；

/***********************************************************
* 01/31
***********************************************************/
1、修改reg_bank;
2、从reg_bank中引出cca阈值到cca_detect模块中;
3、修改cca_detect中的位宽;
4、ILA的debug信号应控制在200-300之间;

/***********************************************************
 * 02/01
***********************************************************/
1、修改了逻辑分析仪的抓取时钟，使20M进行同步抓取。避免异步抓取的数据跳变问题。
2、修改了cca_detect的时钟，由80M改为20M，去掉en_20M。
3、软件增加了测试逻辑，通过CCA检测，但要去掉Dump数据的部分。

/***********************************************************
 * 02/02
***********************************************************/
1、完成beacon,scan,connect三个步骤;
/***********************************************************
 * 03/20
***********************************************************/
1、长多径时延解决方案：改用802.11AC帧结构；
2、大多普勒频移解决方案：根据统计方案计算多普勒频移代价函数；
3
远距离传输解决方案：MIMO+波束成型；

/***********************************************************
 * 
***********************************************************/
rwWlanNxMACHW.v
else if(phyErr | hwErr | macPHYIFOverflow | macPHYIFUnderRun | rxFIFOOverFlow | dmaInternalError)
  internalError <= 1'b1;

TxStateCtl.v -----
assign txData = (txstateCs == TX_VECTOR) ? txVector : (continuousTx) ? continuousTxData : mpIFTxFifoDataout;


  always @(posedge clk or negedge rst_n)
  begin
    if(!rst_n)
      stopTxFlg <= 1'b0;
    else if ((mpIFClkSoftRst_n == 1'b0) || (txstateCs == TX_END) || startTx_p)
      stopTxFlg <= 1'b0;
    else if((stopTx_p) && (txstateCs == TX_VECTOR))
      stopTxFlg <= 1'b1;
  end

TX_VECTOR:
  if(txVectorCnt == 5'd20)
  begin
    if(stopTxFlg || stopTx_p)
      txstateNs = TX_END;
    else
      txstateNs = TX_DATA;
  end
  else if(phyErr_p)
    txstateNs = TX_END;
  else
    txstateNs = txstateCs;

TX_DATA:
  if(txEnd_p == 1'b1)
    txstateNS = IDLE;
  else if(stopTx_p || phyErr_p)
    txstataNS = TX_END;
  else
    txstateNs = txstateCs;

TX_END:
  if(txEnd_p)
    txstateNs = IDLE;
  else
    txstateNs = txstateCs;

default:
  txstateNs = IDLE;


if(txstateCs == TX_VECTOR)
  txReq     <= 1'b1;
else if(txEnd_p || stopTx_p || stopTxFlg || (txstateCs == IDLE))
  txReq     <= 1'b0;

if(txstateCs == TX_DATA)
begin
  if (mpIfFifoReadEn == 1'b1)
    macDataValid    <= 1'b1;
  else
    macDataValid    <= 1'b0;
end
else
    macDataValid    <= 1'b0;


/***********************************************************
 * 中断问题
***********************************************************/
assign oredIntTxTrigger = statussetTxTrigger      ||
                          statussetccaTxTrigger   ||
                          statussetac3TxBufTrigger||
                          statussetac2TxBufTrigger||
                          statussetac1TxBufTrigger||
                          statussetac0TxBufTrigger||
                          statussetbcnTxBufTrigger||
                          statussetac3TxTrigger   ||
                          statussetac2TxTrigger   ||
                          statussetac1TxTrigger   ||
                          statussetac0TxTrigger   ||
                          statussetbcnTxTrigger;

statussetac3TxTrigger <-- intCtrl.v <-- macCSReg.v <--

/***********************************************************
 * 低功耗技术
***********************************************************/
1、编码方式，尽量减少寄存器的翻转次数；
2、减少动态功耗，减少时钟信号摆幅，降低时钟频率，简化电路结构；
3、利用双边沿触发器，这样保持原来数据处理频率的条件下，时钟信号的频率可以减半，由此可以降低集成电路的功耗降低。
4、由于同步电路所有的时序单元都随着时钟的跳变而翻转，因此时钟的功耗是比较大的。异步电路不是所有时序单元都受同一个时钟控制
所以使用异步电路使得某些触发器的时钟跳变次数大大减少。
5、门控时钟。它是指时序电路的端仅在时钟需要引入时才引入。

/***********************************************************
 * 序列检测器
***********************************************************/
1、序列检测器使用状态机进行检测，关键在于给定待检序列的第一bit位。
2、采用状态机进行检测，如果第一bit位不满足，应根据当前状态决定跳转返回到原状态。
/***********************************************************
 * 卡诺图 
***********************************************************/

/***********************************************************
 * 组合逻辑电路的分析方法
***********************************************************/
1、电路任一时刻的输出状态只决定于该时刻各输入状态的组合，
而与电路的原状态无关。组合电路就是由门电路组合而成，没有记忆
单元，没有反馈通路。

/***********************************************************
 * 组合逻辑中的竞争冒险
***********************************************************/
1、由于延迟时间的存在，当一个输入信号经过多条路径传送后又重新
会合到某个门上，由于不同路径上门的级数不同，导致到达会合点的时间
有先有后，从而产生瞬间的错误输出。

/***********************************************************
 * 冒险现象的识别
***********************************************************/
1、采用代数法判断一个组合电路是否存在冒险：
写出组合逻辑电路的逻辑表达式，当某些逻辑变量取特定值(0或1)时，
如果表达式能装换为：
L=A与A逆则存在1冒险，L=A或A逆，则存在0冒险。

/***********************************************************
 * 冒险现象的消除方法
***********************************************************/
1、修改逻辑设计(增加冗余项，变换逻辑式)；
2、增加选通信号；
3、增加输出滤波电容；



